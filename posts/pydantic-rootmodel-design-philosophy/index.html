<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Pydantic RootModel의 설계 의도와 v2에서의 올바른 타입 매핑" /><meta property="og:locale" content="en" /><meta name="description" content="서론" /><meta property="og:description" content="서론" /><link rel="canonical" href="https://snmhz.github.io/posts/pydantic-rootmodel-design-philosophy/" /><meta property="og:url" content="https://snmhz.github.io/posts/pydantic-rootmodel-design-philosophy/" /><meta property="og:site_name" content="Archive" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-06-19T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Pydantic RootModel의 설계 의도와 v2에서의 올바른 타입 매핑" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-06-19T00:00:00+09:00","datePublished":"2025-06-19T00:00:00+09:00","description":"서론","headline":"Pydantic RootModel의 설계 의도와 v2에서의 올바른 타입 매핑","mainEntityOfPage":{"@type":"WebPage","@id":"https://snmhz.github.io/posts/pydantic-rootmodel-design-philosophy/"},"url":"https://snmhz.github.io/posts/pydantic-rootmodel-design-philosophy/"}</script><title>Pydantic RootModel의 설계 의도와 v2에서의 올바른 타입 매핑 | Archive</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Archive"><meta name="application-name" content="Archive"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/image/bio-photo.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Archive</a></div><div class="site-subtitle font-italic">Hi, there</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/SNMHZ" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="javascript:location.href = 'mailto:' + ['snmhz325','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Pydantic RootModel의 설계 의도와 v2에서의 올바른 타입 매핑</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Pydantic RootModel의 설계 의도와 v2에서의 올바른 타입 매핑</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1750258800" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Jun 19, 2025 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://github.com/SNMHZ">SNMHZ</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2332 words"> <em>12 min</em> read</span></div></div></div><div class="post-content"><h2 id="서론"><span class="mr-2">서론</span><a href="#서론" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Pydantic은 Python에서 데이터 검증과 설정 관리를 위한 핵심 라이브러리로 자리잡았습니다. <br /> 그 중에서도 RootModel(또는 v1의 <code class="language-plaintext highlighter-rouge">__root__</code> 필드)은 특별한 용도로 설계된 기능입니다.</p><p>하지만 많은 개발자들이 이 기능을 자동 타입 매핑 용도로 활용하면서, <br /> v2에서의 변경사항과 함께 혼란이 생겨났습니다.</p><p>이 글에서는 RootModel의 본래 설계 의도부터 실제 사용 패턴, <br /> 그리고 v2에서의 변화와 권장되는 구현 방법까지 체계적으로 다루어보겠습니다.</p><h2 id="목차"><span class="mr-2">목차</span><a href="#목차" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><a href="#1-rootmodel의-원래-설계-의도">1. RootModel의 원래 설계 의도</a><li><a href="#2-자동-타입-매핑의-부수적-활용">2. 자동 타입 매핑의 부수적 활용</a><li><a href="#3-pydantic-v2에서의-변화">3. Pydantic v2에서의 변화</a><li><a href="#4-v2에서-권장되는-자동-타입-매핑-방법">4. v2에서 권장되는 자동 타입 매핑 방법</a><li><a href="#5-v1v2-호환-코드-작성-전략">5. v1/v2 호환 코드 작성 전략</a><li><a href="#6-구현-방향성과-모범-사례">6. 구현 방향성과 모범 사례</a><li><a href="#7-결론-및-권장사항">7. 결론 및 권장사항</a></ul><h2 id="1-rootmodel의-원래-설계-의도"><span class="mr-2">1. RootModel의 원래 설계 의도</span><a href="#1-rootmodel의-원래-설계-의도" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="핵심-목적---단일-값-래핑"><span class="mr-2">핵심 목적 - 단일 값 래핑</span><a href="#핵심-목적---단일-값-래핑" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Pydantic의 RootModel은 <strong>“모델 전체가 하나의 값만을 가질 때 그 값을 검증하고 감싸는 것”</strong>이 본래 목적입니다. <br /> 일반적인 BaseModel이 여러 필드를 가진 구조화된 데이터를 다루는 반면, <br /> RootModel은 단순한 리스트, 딕셔너리, 또는 단일 객체 전체를 하나의 “루트 값”으로 취급합니다.</p><h3 id="pydantic-v1에서의-구현"><span class="mr-2">Pydantic v1에서의 구현</span><a href="#pydantic-v1에서의-구현" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>v1에서는 <code class="language-plaintext highlighter-rouge">__root__</code> 필드를 통해 이를 구현했습니다.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="n">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span>

<span class="k">class</span> <span class="nc">Pets</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">__root__</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">PetsByName</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">__root__</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>

<span class="c1"># 사용 예시
</span><span class="n">pets</span> <span class="o">=</span> <span class="n">Pets</span><span class="p">.</span><span class="nf">parse_obj</span><span class="p">([</span><span class="sh">'</span><span class="s">dog</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">cat</span><span class="sh">'</span><span class="p">])</span>
<span class="nf">print</span><span class="p">(</span><span class="n">pets</span><span class="p">.</span><span class="n">__root__</span><span class="p">)</span>  <span class="c1"># ['dog', 'cat']
</span></pre></table></code></div></div><p>이 방식의 핵심은 <strong>입력 데이터 전체가 곧 모델의 값</strong>이라는 점입니다. <br /> 복잡한 필드 구조 없이 단순한 컬렉션이나 값을 Pydantic의 검증 시스템 내에서 다룰 수 있게 해줍니다.</p><h2 id="2-자동-타입-매핑의-부수적-활용"><span class="mr-2">2. 자동 타입 매핑의 부수적 활용</span><a href="#2-자동-타입-매핑의-부수적-활용" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="union과-discriminator의-조합"><span class="mr-2">Union과 Discriminator의 조합</span><a href="#union과-discriminator의-조합" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>v1에서 개발자들은 <code class="language-plaintext highlighter-rouge">__root__</code> 필드에 Union 타입을 적용하여 자동 타입 매핑을 구현했습니다. <br /> 이것은 본래 의도된 용법은 아니었지만, 실용적인 해결책으로 널리 사용되었습니다.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Literal</span>
<span class="kn">from</span> <span class="n">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">Field</span>

<span class="k">class</span> <span class="nc">MySchema1</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="nb">type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="sh">'</span><span class="s">schema1</span><span class="sh">'</span><span class="p">]</span>
    <span class="n">a</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">b</span><span class="p">:</span> <span class="nb">int</span>

<span class="k">class</span> <span class="nc">MySchema2</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="nb">type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="sh">'</span><span class="s">schema2</span><span class="sh">'</span><span class="p">]</span>
    <span class="n">a</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">c</span><span class="p">:</span> <span class="nb">int</span>

<span class="k">class</span> <span class="nc">RootModel</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">__root__</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MySchema1</span><span class="p">,</span> <span class="n">MySchema2</span><span class="p">]</span> <span class="o">=</span> <span class="nc">Field</span><span class="p">(</span><span class="n">discriminator</span><span class="o">=</span><span class="sh">'</span><span class="s">type</span><span class="sh">'</span><span class="p">)</span>
</pre></table></code></div></div><p>이 패턴은 입력 데이터의 특정 필드(discriminator) 값에 따라 <br /> 자동으로 적절한 스키마로 매핑하는 기능을 제공했습니다.</p><h3 id="왜-이런-활용이-가능했는가"><span class="mr-2">왜 이런 활용이 가능했는가</span><a href="#왜-이런-활용이-가능했는가" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>v1의 <code class="language-plaintext highlighter-rouge">__root__</code> 구조는 충분히 유연해서 Union 타입과 discriminator를 함께 사용할 수 있었습니다. <br /> 이는 설계상 의도된 것은 아니었지만, 실제로는 매우 유용한 패턴으로 자리잡았습니다.</p><p>개발자들은 이를 통해 <strong>하나의 API 엔드포인트에서 여러 다른 형태의 데이터를 받아 <br /> 자동으로 적절한 모델로 파싱</strong>하는 기능을 구현할 수 있었습니다.</p><h2 id="3-pydantic-v2에서의-변화"><span class="mr-2">3. Pydantic v2에서의 변화</span><a href="#3-pydantic-v2에서의-변화" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="rootmodel의-재설계"><span class="mr-2">RootModel의 재설계</span><a href="#rootmodel의-재설계" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>v2에서는 <code class="language-plaintext highlighter-rouge">__root__</code> 필드가 완전히 제거되고 <code class="language-plaintext highlighter-rouge">RootModel</code> 클래스로 대체되었습니다. <br /> 이는 단순한 API 변경이 아니라 <strong>본질적 목적에 맞는 재설계</strong>였습니다.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="n">pydantic</span> <span class="kn">import</span> <span class="n">RootModel</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="c1"># v2 방식
</span><span class="k">class</span> <span class="nc">Pets</span><span class="p">(</span><span class="n">RootModel</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]):</span>
    <span class="k">pass</span>

<span class="n">pets</span> <span class="o">=</span> <span class="n">Pets</span><span class="p">.</span><span class="nf">model_validate</span><span class="p">([</span><span class="sh">'</span><span class="s">dog</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">cat</span><span class="sh">'</span><span class="p">])</span>
<span class="nf">print</span><span class="p">(</span><span class="n">pets</span><span class="p">.</span><span class="n">root</span><span class="p">)</span>  <span class="c1"># ['dog', 'cat']
</span></pre></table></code></div></div><h3 id="자동-타입-매핑-지원의-제한"><span class="mr-2">자동 타입 매핑 지원의 제한</span><a href="#자동-타입-매핑-지원의-제한" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>v2의 RootModel은 <strong>단일 값 래핑이라는 본래 목적에 더욱 집중</strong>하도록 설계되었습니다. <br /> 이 과정에서 v1에서 가능했던 Union + discriminator 조합이 공식적으로 지원되지 않게 되었습니다.</p><p>실제로 <a href="https://github.com/pydantic/pydantic/issues/9830">GitHub 이슈 #9830</a>에서 확인할 수 있듯이, <br /> RootModel에 discriminator를 적용하면 TypeError가 발생하거나 예상과 다르게 동작하는 <strong>알려진 버그</strong>가 존재합니다.</p><h3 id="마이그레이션의-어려움"><span class="mr-2">마이그레이션의 어려움</span><a href="#마이그레이션의-어려움" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>이러한 변화로 인해 v1에서 <code class="language-plaintext highlighter-rouge">DictionaryInspectorClass.parse_obj(_rows).__root__</code> 같은 패턴을 사용하던 코드들은 <br /> v2에서 <code class="language-plaintext highlighter-rouge">DictionaryInspectorClass.model_validate(_rows).root</code>로 변경해야 하지만, <br /> 동시에 <strong>자동 타입 매핑 기능을 잃게</strong> 되었습니다.</p><h2 id="4-v2에서-권장되는-자동-타입-매핑-방법"><span class="mr-2">4. v2에서 권장되는 자동 타입 매핑 방법</span><a href="#4-v2에서-권장되는-자동-타입-매핑-방법" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="1-basemodel--union--fielddiscriminator"><span class="mr-2">1. BaseModel + Union + Field(discriminator)</span><a href="#1-basemodel--union--fielddiscriminator" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>v2에서 가장 권장되는 방식은 일반 BaseModel의 필드에 Union과 discriminator를 적용하는 것입니다.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Literal</span>
<span class="kn">from</span> <span class="n">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">Field</span>

<span class="k">class</span> <span class="nc">MySchema1</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="nb">type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="sh">'</span><span class="s">schema1</span><span class="sh">'</span><span class="p">]</span>
    <span class="n">a</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">b</span><span class="p">:</span> <span class="nb">int</span>

<span class="k">class</span> <span class="nc">MySchema2</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="nb">type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="sh">'</span><span class="s">schema2</span><span class="sh">'</span><span class="p">]</span>
    <span class="n">a</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">c</span><span class="p">:</span> <span class="nb">int</span>

<span class="k">class</span> <span class="nc">WrapperModel</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MySchema1</span><span class="p">,</span> <span class="n">MySchema2</span><span class="p">]</span> <span class="o">=</span> <span class="nc">Field</span><span class="p">(</span><span class="n">discriminator</span><span class="o">=</span><span class="sh">'</span><span class="s">type</span><span class="sh">'</span><span class="p">)</span>

<span class="c1"># 사용
</span><span class="n">result</span> <span class="o">=</span> <span class="n">WrapperModel</span><span class="p">.</span><span class="nf">model_validate</span><span class="p">({</span><span class="sh">'</span><span class="s">data</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">type</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">schema1</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">:</span> <span class="mi">2</span><span class="p">}})</span>
<span class="nf">print</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>  <span class="c1"># MySchema1(type='schema1', a=1, b=2)
</span></pre></table></code></div></div><h3 id="2-annotated--typeadapter-패턴"><span class="mr-2">2. Annotated + TypeAdapter 패턴</span><a href="#2-annotated--typeadapter-패턴" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>더욱 직접적인 방법으로는 <code class="language-plaintext highlighter-rouge">Annotated</code>와 <code class="language-plaintext highlighter-rouge">TypeAdapter</code>를 활용하는 것입니다.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Annotated</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Literal</span>
<span class="kn">from</span> <span class="n">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">Field</span><span class="p">,</span> <span class="n">TypeAdapter</span>

<span class="k">class</span> <span class="nc">MySchema1</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="nb">type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="sh">'</span><span class="s">schema1</span><span class="sh">'</span><span class="p">]</span>
    <span class="n">a</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">b</span><span class="p">:</span> <span class="nb">int</span>

<span class="k">class</span> <span class="nc">MySchema2</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="nb">type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="sh">'</span><span class="s">schema2</span><span class="sh">'</span><span class="p">]</span>
    <span class="n">a</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">c</span><span class="p">:</span> <span class="nb">int</span>

<span class="c1"># Python 3.10 이상에서는 파이프 연산자 사용 가능
</span><span class="n">MyUnionType</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span>
    <span class="n">MySchema1</span> <span class="o">|</span> <span class="n">MySchema2</span><span class="p">,</span>  <span class="c1"># Union[MySchema1, MySchema2]와 동일
</span>    <span class="nc">Field</span><span class="p">(</span><span class="n">discriminator</span><span class="o">=</span><span class="sh">'</span><span class="s">type</span><span class="sh">'</span><span class="p">)</span>
<span class="p">]</span>

<span class="c1"># TypeAdapter 사용
</span><span class="n">adapter</span> <span class="o">=</span> <span class="nc">TypeAdapter</span><span class="p">(</span><span class="n">MyUnionType</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">adapter</span><span class="p">.</span><span class="nf">validate_python</span><span class="p">({</span><span class="sh">'</span><span class="s">type</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">schema1</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="nf">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># MySchema1(type='schema1', a=1, b=2)
</span></pre></table></code></div></div><h3 id="3-python-310-이상에서의-파이프-연산자"><span class="mr-2">3. Python 3.10 이상에서의 파이프 연산자</span><a href="#3-python-310-이상에서의-파이프-연산자" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Python 3.10 이상에서는 <a href="https://peps.python.org/pep-0604/">PEP 604</a>에 따라 <code class="language-plaintext highlighter-rouge">Union</code> 대신 파이프 연산자(<code class="language-plaintext highlighter-rouge">|</code>)를 사용할 수 있습니다.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1"># Python 3.10 이상
</span><span class="n">MyUnionType</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">MySchema1</span> <span class="o">|</span> <span class="n">MySchema2</span><span class="p">,</span> <span class="nc">Field</span><span class="p">(</span><span class="n">discriminator</span><span class="o">=</span><span class="sh">'</span><span class="s">type</span><span class="sh">'</span><span class="p">)]</span>

<span class="c1"># Python 3.9 이하
</span><span class="n">MyUnionType</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">MySchema1</span><span class="p">,</span> <span class="n">MySchema2</span><span class="p">],</span> <span class="nc">Field</span><span class="p">(</span><span class="n">discriminator</span><span class="o">=</span><span class="sh">'</span><span class="s">type</span><span class="sh">'</span><span class="p">)]</span>
</pre></table></code></div></div><h2 id="5-v1v2-호환-코드-작성-전략"><span class="mr-2">5. v1/v2 호환 코드 작성 전략</span><a href="#5-v1v2-호환-코드-작성-전략" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="조건부-임포트-패턴"><span class="mr-2">조건부 임포트 패턴</span><a href="#조건부-임포트-패턴" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>두 버전을 모두 지원해야 하는 경우, 조건부 임포트를 활용할 수 있습니다.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Annotated</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Literal</span>
<span class="kn">from</span> <span class="n">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">Field</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="n">pydantic</span> <span class="kn">import</span> <span class="n">TypeAdapter</span>
    <span class="c1"># v2 환경
</span>    <span class="k">def</span> <span class="nf">create_parser</span><span class="p">(</span><span class="n">union_type</span><span class="p">):</span>
        <span class="k">return</span> <span class="nc">TypeAdapter</span><span class="p">(</span><span class="n">union_type</span><span class="p">)</span>
<span class="k">except</span> <span class="nb">ImportError</span><span class="p">:</span>
    <span class="c1"># v1 환경
</span>    <span class="kn">from</span> <span class="n">pydantic</span> <span class="kn">import</span> <span class="n">parse_obj_as</span>
    <span class="k">def</span> <span class="nf">create_parser</span><span class="p">(</span><span class="n">union_type</span><span class="p">):</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">data</span><span class="p">:</span> <span class="nf">parse_obj_as</span><span class="p">(</span><span class="n">union_type</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

<span class="c1"># 공통 타입 정의
</span><span class="n">MyUnionType</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">MySchema1</span><span class="p">,</span> <span class="n">MySchema2</span><span class="p">],</span> <span class="nc">Field</span><span class="p">(</span><span class="n">discriminator</span><span class="o">=</span><span class="sh">'</span><span class="s">type</span><span class="sh">'</span><span class="p">)]</span>
<span class="n">parser</span> <span class="o">=</span> <span class="nf">create_parser</span><span class="p">(</span><span class="n">MyUnionType</span><span class="p">)</span>
</pre></table></code></div></div><h2 id="6-구현-방향성과-모범-사례"><span class="mr-2">6. 구현 방향성과 모범 사례</span><a href="#6-구현-방향성과-모범-사례" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="1-명확한-용도-구분"><span class="mr-2">1. 명확한 용도 구분</span><a href="#1-명확한-용도-구분" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>단일 값 래핑이 목적</strong>이라면 <a href="https://docs.pydantic.dev/latest/api/root_model/">RootModel</a>을 사용하세요<li><strong>자동 타입 매핑이 목적</strong>이라면 Annotated + Union + Field(discriminator) 패턴을 사용하세요</ul><h3 id="2-discriminator-필드-설계"><span class="mr-2">2. Discriminator 필드 설계</span><a href="#2-discriminator-필드-설계" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>모든 스키마에 공통으로 존재하는 discriminator 필드를 반드시 정의하세요.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Schema1</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="nb">type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="sh">'</span><span class="s">type1</span><span class="sh">'</span><span class="p">]</span>  <span class="c1"># discriminator 필드
</span>    <span class="c1"># 기타 필드들...
</span>
<span class="k">class</span> <span class="nc">Schema2</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="nb">type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="sh">'</span><span class="s">type2</span><span class="sh">'</span><span class="p">]</span>  <span class="c1"># discriminator 필드
</span>    <span class="c1"># 기타 필드들...
</span></pre></table></code></div></div><h3 id="3-성능과-에러-처리-고려"><span class="mr-2">3. 성능과 에러 처리 고려</span><a href="#3-성능과-에러-처리-고려" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Discriminated Union은 일반 Union보다 <strong>빠른 검증 속도</strong>와 <strong>명확한 에러 메시지</strong>를 제공합니다. <br /> <a href="https://docs.pydantic.dev/latest/concepts/unions/#discriminated-unions">Pydantic 공식 문서</a>에 따르면, <br /> discriminated union의 로직이 Rust로 구현되어 있어 성능상 큰 이점이 있습니다. <br /> 따라서 가능한 한 discriminator를 활용하는 것이 좋습니다.</p><h3 id="4-중첩된-discriminator-활용"><span class="mr-2">4. 중첩된 Discriminator 활용</span><a href="#4-중첩된-discriminator-활용" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>복잡한 타입 구조에서는 중첩된 discriminator를 활용할 수 있습니다.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1"># 먼저 색깔로 구분
</span><span class="n">Cat</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">BlackCat</span><span class="p">,</span> <span class="n">WhiteCat</span><span class="p">],</span> <span class="nc">Field</span><span class="p">(</span><span class="n">discriminator</span><span class="o">=</span><span class="sh">'</span><span class="s">color</span><span class="sh">'</span><span class="p">)]</span>
<span class="c1"># 그 다음 동물 종류로 구분
</span><span class="n">Pet</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Cat</span><span class="p">,</span> <span class="n">Dog</span><span class="p">],</span> <span class="nc">Field</span><span class="p">(</span><span class="n">discriminator</span><span class="o">=</span><span class="sh">'</span><span class="s">pet_type</span><span class="sh">'</span><span class="p">)]</span>
</pre></table></code></div></div><h2 id="7-결론-및-권장사항"><span class="mr-2">7. 결론 및 권장사항</span><a href="#7-결론-및-권장사항" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Pydantic의 RootModel은 <strong>단일 값 래핑</strong>이라는 명확한 목적을 가지고 설계되었습니다. <br /> v1에서 가능했던 자동 타입 매핑은 부수적인 활용법이었으며, <br /> v2에서는 이를 위한 별도의 패턴이 권장됩니다.</p><h3 id="최종-권장사항"><span class="mr-2">최종 권장사항</span><a href="#최종-권장사항" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li><strong>새로운 프로젝트</strong>: Python 3.10 이상이라면 파이프 연산자와 TypeAdapter를 활용하세요<li><strong>기존 프로젝트 마이그레이션</strong>: Annotated + Union + Field(discriminator) 패턴으로 점진적 마이그레이션하세요<li><strong>v1/v2 호환성</strong>: 조건부 임포트나 호환성 라이브러리를 고려하세요</ol><p>위 권장사항들은 저의 개발 과정에서 마주친 문제들을 해결하기 위해 조사한 결과입니다. <br /></p><p>v1/v2 호환성을 위해 이 문제를 조사하게 되었는데, <br /> RootModel의 자동 타입 매핑 기능이 v2에서 제거되면서 기존 코드를 어떻게 마이그레이션해야 할지 고민이 많았거든요.</p><p>조사 결과 <code class="language-plaintext highlighter-rouge">TypeAdapter</code> + <code class="language-plaintext highlighter-rouge">Annotated</code> 패턴이 가장 안전하고 공식적인 방법이라는 것이라고 판단했습니다. <br /> 여기서 정리한 내용들이 다른 분들에게도 도움이 되길 바랍니다.</p><p>이러한 접근 방식을 통해 Pydantic의 강력한 타입 시스템을 최대한 활용하면서도, <br /> 각 버전의 설계 철학에 맞는 코드를 작성할 수 있으리라 생각합니다.</p><p>결국 도구의 본래 목적을 이해하고 적절한 패턴을 선택하는 것이, <br /> 유지보수 가능하고 안정적인 코드를 만드는 핵심이 아닐까.. 합니다.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/tech/'>Tech</a>, <a href='/categories/python/'>Python</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/pydantic/" class="post-tag no-text-decoration" >Pydantic</a> <a href="/tags/python/" class="post-tag no-text-decoration" >Python</a> <a href="/tags/%ED%83%80%EC%9E%85%EA%B2%80%EC%A6%9D/" class="post-tag no-text-decoration" >타입검증</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Pydantic%20RootModel%EC%9D%98%20%EC%84%A4%EA%B3%84%20%EC%9D%98%EB%8F%84%EC%99%80%20v2%EC%97%90%EC%84%9C%EC%9D%98%20%EC%98%AC%EB%B0%94%EB%A5%B8%20%ED%83%80%EC%9E%85%20%EB%A7%A4%ED%95%91%20-%20Archive&url=https%3A%2F%2Fsnmhz.github.io%2Fposts%2Fpydantic-rootmodel-design-philosophy%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Pydantic%20RootModel%EC%9D%98%20%EC%84%A4%EA%B3%84%20%EC%9D%98%EB%8F%84%EC%99%80%20v2%EC%97%90%EC%84%9C%EC%9D%98%20%EC%98%AC%EB%B0%94%EB%A5%B8%20%ED%83%80%EC%9E%85%20%EB%A7%A4%ED%95%91%20-%20Archive&u=https%3A%2F%2Fsnmhz.github.io%2Fposts%2Fpydantic-rootmodel-design-philosophy%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fsnmhz.github.io%2Fposts%2Fpydantic-rootmodel-design-philosophy%2F&text=Pydantic%20RootModel%EC%9D%98%20%EC%84%A4%EA%B3%84%20%EC%9D%98%EB%8F%84%EC%99%80%20v2%EC%97%90%EC%84%9C%EC%9D%98%20%EC%98%AC%EB%B0%94%EB%A5%B8%20%ED%83%80%EC%9E%85%20%EB%A7%A4%ED%95%91%20-%20Archive" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/airflow-dag-parsing-optimization/">Airflow DAG 파싱 주기 설정 시 주의할 점과 최적화 전략</a><li><a href="/posts/embedding-and-latent-vector/">Embedding과 Latent Vector, 헷갈리는 개념 정리</a><li><a href="/posts/fft-and-latent-vector/">FFT 압축 결과는 왜 Latent Vector가 아닐까?</a><li><a href="/posts/py310-to-py311-str-enum-changes/">Python 3.10에서 3.11로 마이그레이션 시 str, Enum 문자열 출력 동작 변경과 대응 전략</a><li><a href="/posts/python-keeps-you-on-your-toes/">파이썬 개발자가 가져야 할 자세</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/naver-boostcamp-ai-tech/">NAVER BoostCamp AI Tech</a> <a class="post-tag" href="/tags/deep-learning/">Deep Learning</a> <a class="post-tag" href="/tags/python/">Python</a> <a class="post-tag" href="/tags/cuda/">CUDA</a> <a class="post-tag" href="/tags/%ED%9A%8C%EA%B3%A0/">회고</a> <a class="post-tag" href="/tags/airflow/">Airflow</a> <a class="post-tag" href="/tags/boj/">boj</a> <a class="post-tag" href="/tags/data-compression/">Data Compression</a> <a class="post-tag" href="/tags/embedding/">embedding</a> <a class="post-tag" href="/tags/enum/">Enum</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/py310-to-py311-str-enum-changes/"><div class="card-body"> <em class="small" data-ts="1747321200" data-df="ll" > May 16, 2025 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Python 3.10에서 3.11로 마이그레이션 시 str, Enum 문자열 출력 동작 변경과 대응 전략</h3><div class="text-muted small"><p> 서론 Python 3.11에서는 str, Enum 다중상속 클래스의 문자열 출력 동작이 크게 변경되었습니다. 이 변화는 열거형 클래스의 일관성을 높이기 위한 의도적인 수정이지만, 이미 작성된 코드 호환성에 직접적인 영향을 주므로 주의가 필요합니다. 목차 1. Python 3.10과 3.11의 차이점 2. 영향받는 코드 3. 해결책:...</p></div></div></a></div><div class="card"> <a href="/posts/python-keeps-you-on-your-toes/"><div class="card-body"> <em class="small" data-ts="1747407600" data-df="ll" > May 17, 2025 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>파이썬 개발자가 가져야 할 자세</h3><div class="text-muted small"><p> 서론 파이썬은 지속적으로 발전하는 프로그래밍 언어로, 버전 업그레이드마다 새로운 기능과 변경사항이 도입됩니다. 이러한 변화는 기존 코드의 동작에 대한 영향을 매우 크게 강요하는 경우도 꽤나 흔합니다. 특히 이전 글에서 설명한 Python 3.11에서 str과 Enum의 동작 변경은 많은 개발자들에게 주의가 필요한 단적인 예시입니다. 목차 ...</p></div></div></a></div><div class="card"> <a href="/posts/numpy-float-deprecation/"><div class="card-body"> <em class="small" data-ts="1749135600" data-df="ll" > Jun 6, 2025 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>NumPy 1.24 이후 np.float 타입 제거 및 대응 전략</h3><div class="text-muted small"><p> NumPy를 사용하다 보면 가끔 예상치 못한 버전 업데이트 변경점에 당황할 때가 있습니다. NumPy 1.24 버전에서 np.float와 같은 일부 타입들이 완전히 제거된 것이 바로 그런 경우입니다. 많은 기존 코드에 영향을 줄 수 있는 이 변화는 사실 NumPy의 타입 시스템을 더 명확하게 만들고, 오랜 기간 존재했던 혼란을 해결하기 위한 중요...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/numpy-float-deprecation/" class="btn btn-outline-primary" prompt="Older"><p>NumPy 1.24 이후 np.float 타입 제거 및 대응 전략</p></a><div class="btn btn-outline-primary disabled" prompt="Newer"><p>-</p></div></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/naver-boostcamp-ai-tech/">NAVER BoostCamp AI Tech</a> <a class="post-tag" href="/tags/deep-learning/">Deep Learning</a> <a class="post-tag" href="/tags/python/">Python</a> <a class="post-tag" href="/tags/cuda/">CUDA</a> <a class="post-tag" href="/tags/%ED%9A%8C%EA%B3%A0/">회고</a> <a class="post-tag" href="/tags/airflow/">Airflow</a> <a class="post-tag" href="/tags/boj/">boj</a> <a class="post-tag" href="/tags/data-compression/">Data Compression</a> <a class="post-tag" href="/tags/embedding/">embedding</a> <a class="post-tag" href="/tags/enum/">Enum</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/SNMHZ">SNMHZ</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0">Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></div></footer><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-MY8205FV4G"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-MY8205FV4G'); }); </script>
